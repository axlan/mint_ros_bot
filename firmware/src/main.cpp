#include <Arduino.h>

#include <odometry.h>

#include <micro_ros_platformio.h>
#include <rcl/rcl.h>
#include <rclc/rclc.h>
#include <rclc/executor.h>
#include <rclc/timer.h>
#include <std_msgs/msg/int32.h>
#include <geometry_msgs/msg/twist.h>

// Combines
// www.hackster.io/amal-shaji/differential-drive-robot-using-ros2-and-esp32-aae289
// https://github.com/micro-ROS/micro_ros_platformio/blob/main/examples/ethernet_pubsub/src/main.cpp

////// Pin declarations

static constexpr int8_t PIN_LED = 2;

//// Left wheel
// Control pins need to be able to generate PWM
static constexpr int8_t PIN_L_FORW = 5;
static constexpr int8_t PIN_L_BACK = 18;
// Encoder needs to support interrupts.
static constexpr int8_t PIN_L_ENCODER = 12;

//// Right wheel
// Control pins need to be able to generate PWM
static constexpr int8_t PIN_R_FORW = 19;
static constexpr int8_t PIN_R_BACK = 21;
// Encoder needs to support interrupts.
static constexpr int8_t PIN_R_ENCODER = 13;

////// Parameters of the robot
// Units in meters
static constexpr float WHEELS_Y_DISTANCE = 0.173;
static constexpr float WHEEL_RADIUS = 0.0245;
static constexpr float WHEEL_CIRCUMFERENCE = 0.153;
//// Encoder value per revolution of left wheel and right wheel
static constexpr int TICK_PER_REVOLUTION_LW = 4000;
static constexpr int TICK_PER_REVOLUTION_RW = 4000;
// Min value for PWM that moves wheels
static constexpr int PWM_THRESHOLD = 100;
//// PID constants of left wheel
static constexpr float PID_KP_L = 1.8;
static constexpr float PID_KI_L = 5;
static constexpr float PID_KD_L = 0.1;
//// PID constants of right wheel
static constexpr float PID_KP_R = 1.8;
static constexpr float PID_KI_R = 5;
static constexpr float PID_KD_R = 0.1;


//// pwm parameters setup
static constexpr int PWM_FREQ = 30000;
static constexpr int PWM_CHANNEL_L_FORW = 0;
static constexpr int PWM_CHANNEL_L_BACK = 1;
static constexpr int PWM_CHANNEL_R_FORW = 2;
static constexpr int PWM_CHANNEL_R_BACK = 3;
static constexpr int PWM_RESOLUTION = 8;

////// Network configuration
static const IPAddress AGENT_IP(192, 168, 1, 115);
static const uint16_t AGENT_PORT = 8888;
// For some reason these need to be passed as mutable to set_microros_wifi_transports?
char WIFI_SSID[] = "my_wifi_ssid";
char WIFI_PASSWORD[] = "p455w0rd";

////// ROS node configuration
static constexpr const char *ROS_NODE_NAME = "franken_mint_node";
static constexpr int ROS_EXECUTOR_TIMEOUT = 100; // ms

// Update controller at 10Hz.
static constexpr unsigned int CONTROL_TIMER_PERIOD_MS = 100;

// creating a class for motor control
class MotorController
{
public:
  std_msgs__msg__Int32 EncoderCount;
  volatile long CurrentPosition;
  volatile long PreviousPosition;
  volatile long CurrentTime;
  volatile long PreviousTime;
  volatile long CurrentTimeforError;
  volatile long PreviousTimeForError;
  float rpmFilt;
  float eintegral;
  float ederivative;
  float rpmPrev;
  float kp;
  float ki;
  float kd;
  float error;
  float previousError = 0;
  int tick;
  bool is_in_reverse = false;

  MotorController(int tickPerRevolution)
  {
    this->tick = tickPerRevolution;
  }

  // initializing the parameters of PID controller
  void initPID(float proportionalGain, float integralGain, float derivativeGain)
  {
    kp = proportionalGain;
    ki = integralGain;
    kd = derivativeGain;
  }

  // function return rpm of the motor using the encoder tick values
  float getRpm()
  {
    CurrentPosition = EncoderCount.data;
    CurrentTime = millis();
    float delta1 = ((float)CurrentTime - PreviousTime) / 1.0e3;
    float velocity = ((float)CurrentPosition - PreviousPosition) / delta1;
    float rpm = (velocity / tick) * 60;
    rpmFilt = 0.854 * rpmFilt + 0.0728 * rpm + 0.0728 * rpmPrev;
    float rpmPrev = rpm;
    PreviousPosition = CurrentPosition;
    PreviousTime = CurrentTime;
    // Serial.println(rpmFilt);
    return rpmFilt;
  }

  // pid controller
  float pid(float setpoint, float feedback)
  {
    CurrentTimeforError = millis();
    float delta2 = ((float)CurrentTimeforError - PreviousTimeForError) / 1.0e3;
    error = setpoint - feedback;
    eintegral = eintegral + (error * delta2);
    ederivative = (error - previousError) / delta2;
    float control_signal = (kp * error) + (ki * eintegral) + (kd * ederivative);

    previousError = error;
    PreviousTimeForError = CurrentTimeforError;
    return control_signal;
  }
  // move the robot wheels based the control signal generated by the pid controller
  void moveBase(float ActuatingSignal, int threshold, int pwmChannel)
  {
    is_in_reverse = ActuatingSignal < 0;
    int pwm = threshold + (int)fabs(ActuatingSignal);
    if (pwm > 255)
      pwm = 255;
    ledcWrite(pwmChannel, pwm);
  }
};

////// Global variables

// ROS entities
rclc_executor_t executor;
rclc_support_t support;
rcl_allocator_t allocator;
rcl_node_t node;
rcl_publisher_t publisher;
rcl_subscription_t subscriber;
rcl_timer_t control_timer;

// Message buffers
geometry_msgs__msg__Twist cmd_msg;
nav_msgs__msg__Odometry odom_msg;

unsigned long long time_offset = 0;
unsigned long prev_odom_update = 0;
Odometry odometry;

// creating objects for right wheel and left wheel
MotorController leftWheel(TICK_PER_REVOLUTION_LW);
MotorController rightWheel(TICK_PER_REVOLUTION_RW);

// Connection management
enum class ConnectionState
{
  kInitializing,
  kWaitingForAgent,
  kConnecting,
  kConnected,
  kDisconnected
};
ConnectionState connection_state = ConnectionState::kInitializing;

// interrupt function for left wheel encoder.
void IRAM_ATTR updateEncoderL()
{
  if (!leftWheel.is_in_reverse)
    leftWheel.EncoderCount.data++;
  else
    leftWheel.EncoderCount.data--;
}

// interrupt function for right wheel encoder
void IRAM_ATTR updateEncoderR()
{
  if (!rightWheel.is_in_reverse)
    rightWheel.EncoderCount.data++;
  else
    rightWheel.EncoderCount.data--;
}

struct timespec getTime()
{
  struct timespec tp = {0};
  // add time difference between uC time and ROS time to
  // synchronize time with ROS
  unsigned long long now = millis() + time_offset;
  tp.tv_sec = now / 1000;
  tp.tv_nsec = (now % 1000) * 1000000;
  return tp;
}

// function which publishes wheel odometry.
void publishData()
{
  odom_msg = odometry.getData();

  struct timespec time_stamp = getTime();

  odom_msg.header.stamp.sec = time_stamp.tv_sec;
  odom_msg.header.stamp.nanosec = time_stamp.tv_nsec;
  if (rcl_publish(&publisher, &odom_msg, NULL) != RCL_RET_OK)
  {
    Serial.println("[PUB] Failed");
  }
}

void MotorControllerCallback(rcl_timer_t *timer, int64_t last_call_time)
{
  float linearVelocity;
  float angularVelocity;
  // linear velocity and angular velocity send cmd_vel topic
  linearVelocity = cmd_msg.linear.x;
  angularVelocity = cmd_msg.angular.z;
  // linear and angular velocities are converted to leftwheel and rightwheel velocities
  float vL = (linearVelocity - (angularVelocity * 1 / 2)) * 20;
  float vR = (linearVelocity + (angularVelocity * 1 / 2)) * 20;
  // current wheel rpm is calculated
  float currentRpmL = leftWheel.getRpm();
  float currentRpmR = rightWheel.getRpm();
  // pid controlled is used for generating the pwm signal
  float actuating_signal_LW = leftWheel.pid(vL, currentRpmL);
  float actuating_signal_RW = rightWheel.pid(vR, currentRpmR);
  if (vL == 0 && vR == 0)
  {
    actuating_signal_LW = 0;
    actuating_signal_RW = 0;
  }
  else
  {
    if (actuating_signal_LW >= 0)
    {
      leftWheel.moveBase(actuating_signal_LW, PWM_THRESHOLD, PWM_CHANNEL_L_FORW);
      leftWheel.moveBase(0, PWM_THRESHOLD, PWM_CHANNEL_L_BACK);
    }
    else
    {
      leftWheel.moveBase(actuating_signal_LW, PWM_THRESHOLD, PWM_CHANNEL_L_BACK);
      leftWheel.moveBase(0, PWM_THRESHOLD, PWM_CHANNEL_L_FORW);
    }

    if (actuating_signal_RW >= 0)
    {
      rightWheel.moveBase(actuating_signal_RW, PWM_THRESHOLD, PWM_CHANNEL_R_FORW);
      rightWheel.moveBase(0, PWM_THRESHOLD, PWM_CHANNEL_R_BACK);
    }
    else
    {
      rightWheel.moveBase(actuating_signal_RW, PWM_THRESHOLD, PWM_CHANNEL_R_BACK);
      rightWheel.moveBase(0, PWM_THRESHOLD, PWM_CHANNEL_R_FORW);
    }
  }
  // odometry
  float average_rps_x = ((float)(currentRpmL + currentRpmR) / 2) / 60.0; // RPM
  float linear_x = average_rps_x * WHEEL_CIRCUMFERENCE;                  // m/s
  float average_rps_a = ((float)(-currentRpmL + currentRpmR) / 2) / 60.0;
  float angular_z = (average_rps_a * WHEEL_CIRCUMFERENCE) / (WHEELS_Y_DISTANCE / 2.0); //  rad/s
  float linear_y = 0;
  unsigned long now = millis();
  float vel_dt = (now - prev_odom_update) / 1000.0;
  prev_odom_update = now;
  odometry.update(
      vel_dt,
      linear_x,
      linear_y,
      angular_z);
  publishData();
}

// subscription callback function
void SubscriptionCallback(const void *msgin)
{
  Serial.println("[SUB] Got vel command");
}

bool CreateEntities()
{
  allocator = rcl_get_default_allocator();

  // Initialize options and set domain ID
  rcl_init_options_t init_options = rcl_get_zero_initialized_init_options();
  if (rcl_init_options_init(&init_options, allocator) != RCL_RET_OK)
  {
    return false;
  }

  // Initialize support with domain ID options
  if (rclc_support_init_with_options(&support, 0, NULL, &init_options, &allocator) != RCL_RET_OK)
  {
    return false;
  }

  // Clean up initialization options
  if (rcl_init_options_fini(&init_options) != RCL_RET_OK)
  {
    return false;
  }

  // Initialize node and rest of entities
  if (rclc_node_init_default(&node, ROS_NODE_NAME, "", &support) != RCL_RET_OK)
  {
    return false;
  }

  // Create publisher
  if (rclc_publisher_init_default(&publisher, &node,
                                  ROSIDL_GET_MSG_TYPE_SUPPORT(nav_msgs, msg, Odometry),
                                  "odom/unfiltered") != RCL_RET_OK)
  {
    return false;
  }

  // Create subscriber
  if (rclc_subscription_init_default(&subscriber, &node,
                                     ROSIDL_GET_MSG_TYPE_SUPPORT(geometry_msgs, msg, Twist),
                                     "cmd_vel") != RCL_RET_OK)
  {
    return false;
  }

  // timer function for controlling the motor base. At every samplingT time
  // MotorControllerCallback function is called
  // Here I had set SamplingT=10 Which means at every 10 milliseconds MotorControllerCallback function is called
  if (rclc_timer_init_default(
          &control_timer,
          &support,
          RCL_MS_TO_NS(CONTROL_TIMER_PERIOD_MS),
          MotorControllerCallback) != RCL_RET_OK)
  {
    return false;
  }

  // Initialize executor
  // Handle for subscription and control timer
  if (rclc_executor_init(&executor, &support.context, 2, &allocator) != RCL_RET_OK)
  {
    return false;
  }

  // Add subscriber to executor
  if (rclc_executor_add_subscription(&executor, &subscriber, &cmd_msg,
                                     &SubscriptionCallback, ON_NEW_DATA) != RCL_RET_OK)
  {
    return false;
  }

  if (rclc_executor_add_timer(&executor, &control_timer) != RCL_RET_OK)
  {
    return false;
  }

  return true;
}

void DestroyEntities()
{
  rmw_context_t *rmw_context = rcl_context_get_rmw_context(&support.context);
  (void)rmw_uros_set_context_entity_destroy_session_timeout(rmw_context, 0);

  rcl_ret_t rc = RCL_RET_OK;
  rc = rcl_timer_fini(&control_timer);
  rc = rcl_subscription_fini(&subscriber, &node);
  rc = rcl_publisher_fini(&publisher, &node);
  rclc_executor_fini(&executor);
  rc = rcl_node_fini(&node);
  rclc_support_fini(&support);
}

void HandleConnectionState()
{
  switch (connection_state)
  {
  case ConnectionState::kWaitingForAgent:
    if (RMW_RET_OK == rmw_uros_ping_agent(200, 3))
    {
      Serial.println("[ROS] Agent found, establishing connection...");
      connection_state = ConnectionState::kConnecting;
    }
    break;

  case ConnectionState::kConnecting:
    if (CreateEntities())
    {
      Serial.println("[ROS] Connected and ready!");
      connection_state = ConnectionState::kConnected;
    }
    else
    {
      Serial.println("[ROS] Connection failed, retrying...");
      connection_state = ConnectionState::kWaitingForAgent;
    }
    break;

  case ConnectionState::kConnected:
    if (RMW_RET_OK != rmw_uros_ping_agent(200, 3))
    {
      Serial.println("[ROS] Agent disconnected!");
      connection_state = ConnectionState::kDisconnected;
    }
    else
    {
      rclc_executor_spin_some(&executor, RCL_MS_TO_NS(ROS_EXECUTOR_TIMEOUT));
    }
    break;

  case ConnectionState::kDisconnected:
    DestroyEntities();
    Serial.println("[ROS] Waiting for agent...");
    connection_state = ConnectionState::kWaitingForAgent;
    break;

  default:
    break;
  }
}

void setup()
{
  Serial.begin(115200);
  Serial.println("[INIT] Starting micro-ROS node...");

  pinMode(PIN_L_FORW, OUTPUT);
  pinMode(PIN_L_BACK, OUTPUT);
  pinMode(PIN_L_ENCODER, INPUT_PULLUP);

  pinMode(PIN_R_FORW, OUTPUT);
  pinMode(PIN_R_BACK, OUTPUT);
  pinMode(PIN_R_ENCODER, INPUT_PULLUP);

  pinMode(PIN_LED, OUTPUT);
  digitalWrite(PIN_LED, LOW);


  // initializing the pid constants
  leftWheel.initPID(PID_KP_L, PID_KI_L, PID_KD_L);
  rightWheel.initPID(PID_KP_R, PID_KI_R, PID_KD_R);

  // initializing interrupt functions for counting the encoder tick values
  // For my particular model the falling edge was much sharper.
  attachInterrupt(digitalPinToInterrupt(PIN_L_ENCODER), updateEncoderL, FALLING);
  attachInterrupt(digitalPinToInterrupt(PIN_R_ENCODER), updateEncoderR, FALLING);

  // initializing pwm signal parameters
  ledcSetup(PWM_CHANNEL_L_FORW, PWM_FREQ, PWM_RESOLUTION);
  ledcAttachPin(PIN_L_FORW, PWM_CHANNEL_L_FORW);
  ledcSetup(PWM_CHANNEL_L_BACK, PWM_FREQ, PWM_RESOLUTION);
  ledcAttachPin(PIN_L_BACK, PWM_CHANNEL_L_BACK);
  ledcSetup(PWM_CHANNEL_R_FORW, PWM_FREQ, PWM_RESOLUTION);
  ledcAttachPin(PIN_R_FORW, PWM_CHANNEL_R_FORW);
  ledcSetup(PWM_CHANNEL_R_BACK, PWM_FREQ, PWM_RESOLUTION);
  ledcAttachPin(PIN_R_BACK, PWM_CHANNEL_R_BACK);


  set_microros_wifi_transports(WIFI_SSID, WIFI_PASSWORD, AGENT_IP, AGENT_PORT);

  delay(2000);
  connection_state = ConnectionState::kWaitingForAgent;
}

void loop()
{
  HandleConnectionState();
  delay(5); // Prevent tight loop, but don't interfere with update rates.
}
